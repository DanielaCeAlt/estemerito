module.exports = [
"[project]/.next-internal/server/app/api/equipos/fallas/route/actions.js [app-rsc] (server actions loader, ecmascript)", ((__turbopack_context__, module, exports) => {

}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/action-async-storage.external.js [external] (next/dist/server/app-render/action-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/action-async-storage.external.js", () => require("next/dist/server/app-render/action-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/process [external] (process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("process", () => require("process"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/tls [external] (tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}),
"[externals]/timers [external] (timers, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("timers", () => require("timers"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/string_decoder [external] (string_decoder, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[project]/src/lib/database.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// =============================================
// CONFIGURACIÓN DE BASE DE DATOS MYSQL
// =============================================
__turbopack_context__.s([
    "callStoredProcedure",
    ()=>callStoredProcedure,
    "closePool",
    ()=>closePool,
    "default",
    ()=>__TURBOPACK__default__export__,
    "executeQuery",
    ()=>executeQuery,
    "getCatalogos",
    ()=>getCatalogos,
    "getConnection",
    ()=>getConnection,
    "getEquiposCompletos",
    ()=>getEquiposCompletos,
    "getHistorialMovimientos",
    ()=>getHistorialMovimientos,
    "getInventarioPorEstatus",
    ()=>getInventarioPorEstatus,
    "getMovimientosDetallados",
    ()=>getMovimientosDetallados,
    "testConnection",
    ()=>testConnection
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mysql2$2f$promise$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mysql2/promise.js [app-route] (ecmascript)");
;
// Configuración de la conexión a la base de datos
const dbConfig = {
    host: process.env.DB_HOST || 'localhost',
    port: parseInt(process.env.DB_PORT || '3306'),
    user: process.env.DB_USER || 'root',
    password: process.env.DB_PASSWORD || '',
    database: process.env.DB_NAME || 'GostCAM',
    charset: 'utf8mb4',
    timezone: '+00:00'
};
// Pool de conexiones para mejor performance
const pool = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mysql2$2f$promise$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].createPool({
    ...dbConfig,
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0
});
const getConnection = async ()=>{
    try {
        const connection = await pool.getConnection();
        return connection;
    } catch (error) {
        console.error('Error connecting to the database:', error);
        throw new Error('Failed to connect to database');
    }
};
const executeQuery = async (query, params = [])=>{
    let connection;
    try {
        connection = await getConnection();
        const [rows] = await connection.execute(query, params);
        return rows;
    } catch (error) {
        console.error('Database query error:', error);
        console.error('Query:', query);
        console.error('Params:', params);
        throw error;
    } finally{
        if (connection) {
            connection.release();
        }
    }
};
const callStoredProcedure = async (procedureName, params = [])=>{
    const placeholders = params.map(()=>'?').join(', ');
    const query = `CALL ${procedureName}(${placeholders})`;
    let connection;
    try {
        connection = await getConnection();
        const [rows] = await connection.execute(query, params);
        // Los procedimientos almacenados devuelven arrays anidados
        return Array.isArray(rows) && Array.isArray(rows[0]) ? rows[0] : rows;
    } catch (error) {
        console.error('Stored procedure error:', error);
        console.error('Procedure:', procedureName);
        console.error('Params:', params);
        throw error;
    } finally{
        if (connection) {
            connection.release();
        }
    }
};
const testConnection = async ()=>{
    try {
        const result = await executeQuery('SELECT 1 as test');
        return result.length > 0;
    } catch (error) {
        console.error('Database connection test failed:', error);
        return false;
    }
};
const closePool = async ()=>{
    try {
        await pool.end();
        console.log('Database pool closed');
    } catch (error) {
        console.error('Error closing database pool:', error);
    }
};
const getEquiposCompletos = async (filters)=>{
    // Usar directamente la tabla equipo con una consulta simple
    return await getEquiposFromTable(filters);
};
// Función fallback para consultar tabla equipos directamente
const getEquiposFromTable = async (filters)=>{
    let query = `
    SELECT 
      e.no_serie,
      e.nombreEquipo,
      e.numeroActivo,
      e.modelo,
      e.fechaAlta,
      e.idPosicion,
      te.nombreTipo as TipoEquipo,
      ee.estatus as EstatusEquipo,
      COALESCE(s.Sucursal, 'Centro Principal') as SucursalActual,
      u.NombreUsuario as UsuarioAsignado
    FROM equipo e
    LEFT JOIN tipoequipo te ON e.idTipoEquipo = te.idTipoEquipo
    LEFT JOIN estatusequipo ee ON e.idEstatus = ee.idEstatus
    LEFT JOIN usuarios u ON e.idUsuarios = u.idUsuarios
    LEFT JOIN posicionequipo pe ON e.idPosicion = pe.idPosicion
    LEFT JOIN sucursales s ON pe.idCentro = s.idCentro
  `;
    const params = [];
    const conditions = [];
    // ✅ Filtrar equipos eliminados lógicamente
    conditions.push('(e.eliminado IS NULL OR e.eliminado = 0)');
    if (filters) {
        if (filters.tipoEquipo) {
            conditions.push('te.nombreTipo = ?');
            params.push(filters.tipoEquipo);
        }
        if (filters.estatus) {
            conditions.push('ee.estatus = ?');
            params.push(filters.estatus);
        }
        if (filters.sucursal) {
            conditions.push('s.Sucursal = ?');
            params.push(filters.sucursal);
        }
        if (filters.usuario) {
            conditions.push('u.NombreUsuario LIKE ?');
            params.push(`%${filters.usuario}%`);
        }
        if (filters.busqueda) {
            // Búsqueda global en todos los campos principales (función fallback)
            conditions.push(`(
        e.nombreEquipo LIKE ? OR 
        e.no_serie LIKE ? OR 
        e.numeroActivo LIKE ? OR
        e.modelo LIKE ? OR
        te.nombreTipo LIKE ? OR
        ee.estatus LIKE ? OR
        s.Sucursal LIKE ? OR
        u.NombreUsuario LIKE ?
      )`);
            // Repetir el término de búsqueda para cada campo
            const termino = `%${filters.busqueda}%`;
            params.push(termino, termino, termino, termino, termino, termino, termino, termino);
        }
    }
    if (conditions.length > 0) {
        query += ' WHERE ' + conditions.join(' AND ');
    }
    query += ' ORDER BY e.fechaAlta DESC';
    const result = await executeQuery(query, params);
    return result;
};
const getMovimientosDetallados = async (filters)=>{
    let query = 'SELECT * FROM VistaMovimientosDetallados';
    const params = [];
    const conditions = [];
    if (filters) {
        if (filters.sucursalOrigen) {
            conditions.push('SucursalOrigen = ?');
            params.push(filters.sucursalOrigen);
        }
        if (filters.sucursalDestino) {
            conditions.push('SucursalDestino = ?');
            params.push(filters.sucursalDestino);
        }
        if (filters.tipoMovimiento) {
            conditions.push('tipoMovimiento = ?');
            params.push(filters.tipoMovimiento);
        }
        if (filters.estatusMovimiento) {
            conditions.push('estatusMovimiento = ?');
            params.push(filters.estatusMovimiento);
        }
        if (filters.fechaDesde) {
            conditions.push('fecha >= ?');
            params.push(filters.fechaDesde);
        }
        if (filters.fechaHasta) {
            conditions.push('fecha <= ?');
            params.push(filters.fechaHasta);
        }
    }
    if (conditions.length > 0) {
        query += ' WHERE ' + conditions.join(' AND ');
    }
    query += ' ORDER BY fecha DESC';
    return executeQuery(query, params);
};
const getInventarioPorEstatus = async ()=>{
    return executeQuery('SELECT * FROM VistaInventarioPorEstatus ORDER BY estatus, TipoEquipo');
};
const getCatalogos = async ()=>{
    try {
        console.log('Obteniendo catálogos...');
        // Función auxiliar para ejecutar consultas con fallback
        const executeWithFallback = async (query, fallback = [])=>{
            try {
                return await executeQuery(query);
            } catch (error) {
                console.warn(`Query failed: ${query}`, error);
                return fallback;
            }
        };
        // Obtener catálogos básicos que probablemente existan
        const usuarios = await executeWithFallback('SELECT * FROM usuarios', []);
        // Para tipos de equipo, intentar múltiples variantes
        const tiposEquipo = await executeWithFallback('SELECT * FROM tipoequipo', []);
        // Para estatus, intentar múltiples variantes  
        const estatusEquipos = await executeWithFallback('SELECT * FROM estatusequipo', []);
        // Para posiciones, usar valores por defecto si no existe
        const posiciones = await executeWithFallback('SELECT * FROM posiciones', [
            {
                id: 1,
                nombre: 'Entrada Principal'
            },
            {
                id: 2,
                nombre: 'Recepción'
            },
            {
                id: 3,
                nombre: 'Oficina'
            }
        ]);
        // Para sucursales, intentar obtener de la tabla de equipos o crear por defecto
        const sucursales = await executeWithFallback('SELECT DISTINCT SucursalActual as nombre, SucursalActual as id FROM equipos WHERE SucursalActual IS NOT NULL AND SucursalActual != ""', [
            {
                id: 'SUC001',
                nombre: 'Sucursal Principal'
            },
            {
                id: 'SUC002',
                nombre: 'Sucursal Norte'
            },
            {
                id: 'SUC003',
                nombre: 'Sucursal Sur'
            }
        ]);
        return {
            tiposEquipo,
            estatusEquipos,
            usuarios,
            posiciones,
            sucursales,
            // Catálogos adicionales vacíos por ahora
            estados: [],
            municipios: [],
            zonas: []
        };
    } catch (error) {
        console.error('Error obteniendo catálogos:', error);
        throw error;
    }
};
const getHistorialMovimientos = async (no_serie)=>{
    if (no_serie) {
        return executeQuery('SELECT * FROM VistaHistorialMovimientos WHERE no_serie = ? ORDER BY fecha DESC', [
            no_serie
        ]);
    }
    return executeQuery('SELECT * FROM VistaHistorialMovimientos ORDER BY fecha DESC LIMIT 100');
};
const __TURBOPACK__default__export__ = pool;
}),
"[project]/src/app/api/equipos/fallas/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GET",
    ()=>GET,
    "POST",
    ()=>POST,
    "PUT",
    ()=>PUT
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/database.ts [app-route] (ecmascript)");
;
;
async function GET(request) {
    try {
        const { searchParams } = new URL(request.url);
        const estatus = searchParams.get('estatus') || 'ABIERTA';
        const prioridad = searchParams.get('prioridad');
        const tipo = searchParams.get('tipo');
        const tecnico = searchParams.get('tecnico');
        const fechaDesde = searchParams.get('fechaDesde');
        const fechaHasta = searchParams.get('fechaHasta');
        const sucursal = searchParams.get('sucursal');
        // Intentar consulta real primero
        let fallas = [];
        try {
            // Consulta base con JOIN mejorado
            let query = `
        SELECT 
          f.*,
          e.nombreEquipo,
          te.nombreTipo as tipoEquipo,
          COALESCE(s.Sucursal, 'Centro Principal') as sucursal,
          DATEDIFF(NOW(), f.fecha_reporte) as diasAbierta
        FROM fallas_equipos f
        INNER JOIN equipo e ON f.no_serie = e.no_serie
        LEFT JOIN tipoequipo te ON e.idTipoEquipo = te.idTipoEquipo
        LEFT JOIN posicionequipo pe ON e.idPosicion = pe.idPosicion
        LEFT JOIN sucursales s ON pe.idCentro = s.idCentro
        WHERE 1=1
      `;
            const params = [];
            // Aplicar filtros
            if ("TURBOPACK compile-time truthy", 1) {
                query += ` AND f.estatus = ?`;
                params.push(estatus);
            }
            if (prioridad) {
                query += ` AND f.prioridad = ?`;
                params.push(prioridad);
            }
            if (tipo) {
                query += ` AND f.tipo_falla = ?`;
                params.push(tipo);
            }
            if (tecnico) {
                query += ` AND f.tecnico_asignado LIKE ?`;
                params.push(`%${tecnico}%`);
            }
            if (fechaDesde) {
                query += ` AND f.fecha_reporte >= ?`;
                params.push(fechaDesde);
            }
            if (fechaHasta) {
                query += ` AND f.fecha_reporte <= ?`;
                params.push(fechaHasta);
            }
            if (sucursal) {
                query += ` AND s.Sucursal LIKE ?`;
                params.push(`%${sucursal}%`);
            }
            query += ` ORDER BY f.fecha_reporte DESC`;
            fallas = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(query, params);
        } catch (error) {
            console.error('Error consultando fallas BD:', error);
            // Si la tabla no existe, devolver array vacío con mensaje claro
            if (error instanceof Error && error.message.includes("doesn't exist")) {
                console.log('⚠️ Tabla fallas_equipos no existe. Crear con script SQL proporcionado.');
                fallas = [];
            } else {
                throw error; // Re-lanzar otros errores
            }
        }
        // Generar estadísticas
        const estadisticas = {
            total: fallas.length,
            abiertas: fallas.filter((f)=>f.estatus === 'ABIERTA').length,
            en_proceso: fallas.filter((f)=>f.estatus === 'EN_PROCESO').length,
            resueltas: fallas.filter((f)=>f.estatus === 'RESUELTA').length,
            promedio_solucion_horas: 0,
            por_tipo: {
                hardware: fallas.filter((f)=>f.tipo_falla === 'HARDWARE').length,
                software: fallas.filter((f)=>f.tipo_falla === 'SOFTWARE').length,
                conectividad: fallas.filter((f)=>f.tipo_falla === 'CONECTIVIDAD').length,
                suministros: fallas.filter((f)=>f.tipo_falla === 'SUMINISTROS').length,
                mecanica: fallas.filter((f)=>f.tipo_falla === 'MECANICA').length,
                electrica: fallas.filter((f)=>f.tipo_falla === 'ELECTRICA').length,
                otra: fallas.filter((f)=>f.tipo_falla === 'OTRA').length
            },
            por_prioridad: {
                baja: fallas.filter((f)=>f.prioridad === 'BAJA').length,
                normal: fallas.filter((f)=>f.prioridad === 'NORMAL').length,
                alta: fallas.filter((f)=>f.prioridad === 'ALTA').length,
                critica: fallas.filter((f)=>f.prioridad === 'CRITICA').length
            },
            por_tecnico: []
        };
        // Calcular promedio de horas de solución
        const fallasResueltas = fallas.filter((f)=>f.estatus === 'RESUELTA' && f.tiempo_solucion_horas);
        if (fallasResueltas.length > 0) {
            const totalHoras = fallasResueltas.reduce((sum, f)=>sum + (f.tiempo_solucion_horas || 0), 0);
            estadisticas.promedio_solucion_horas = Math.round(totalHoras / fallasResueltas.length * 100) / 100;
        }
        // Estadísticas por técnico
        const tecnicosMap = new Map();
        fallas.forEach((falla)=>{
            if (falla.tecnico_asignado) {
                if (!tecnicosMap.has(falla.tecnico_asignado)) {
                    tecnicosMap.set(falla.tecnico_asignado, {
                        tecnico: falla.tecnico_asignado,
                        total_asignadas: 0,
                        resueltas: 0,
                        en_proceso: 0,
                        total_horas: 0,
                        promedio_horas: 0
                    });
                }
                const tecnico = tecnicosMap.get(falla.tecnico_asignado);
                tecnico.total_asignadas++;
                if (falla.estatus === 'RESUELTA') {
                    tecnico.resueltas++;
                    if (falla.tiempo_solucion_horas) {
                        tecnico.total_horas += falla.tiempo_solucion_horas;
                    }
                } else if (falla.estatus === 'EN_PROCESO') {
                    tecnico.en_proceso++;
                }
            }
        });
        // Calcular promedios por técnico
        tecnicosMap.forEach((tecnico)=>{
            if (tecnico.resueltas > 0) {
                tecnico.promedio_horas = Math.round(tecnico.total_horas / tecnico.resueltas * 100) / 100;
            }
            delete tecnico.total_horas;
        });
        estadisticas.por_tecnico = Array.from(tecnicosMap.values());
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            data: {
                fallas,
                estadisticas
            }
        });
    } catch (error) {
        console.error('Error consultando fallas:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            error: 'Error interno del servidor'
        }, {
            status: 500
        });
    }
}
async function POST(request) {
    try {
        const body = await request.json();
        const { no_serie, tipo_falla, descripcion_problema, sintomas, prioridad = 'NORMAL', usuario_reporta, tecnico_asignado, ubicacion_falla, impacto = 'MEDIO', requiere_repuestos = false, observaciones = '' } = body;
        // Validaciones
        if (!no_serie || !tipo_falla || !descripcion_problema || !usuario_reporta || !ubicacion_falla) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: 'Campos requeridos: no_serie, tipo_falla, descripcion_problema, usuario_reporta, ubicacion_falla'
            }, {
                status: 400
            });
        }
        // Verificar que el equipo existe
        const equipoQuery = `SELECT no_serie, nombreEquipo FROM equipo WHERE no_serie = ?`;
        const equipoResult = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(equipoQuery, [
            no_serie
        ]);
        if (equipoResult.length === 0) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: 'Equipo no encontrado'
            }, {
                status: 404
            });
        }
        // Crear tabla si no existe
        const createTableQuery = `
      CREATE TABLE IF NOT EXISTS fallas_equipos (
        id INT AUTO_INCREMENT PRIMARY KEY,
        no_serie VARCHAR(50) NOT NULL,
        tipo_falla ENUM('HARDWARE', 'SOFTWARE', 'CONECTIVIDAD', 'SUMINISTROS', 'MECANICA', 'ELECTRICA', 'OTRA') NOT NULL,
        descripcion_problema TEXT NOT NULL,
        sintomas TEXT,
        prioridad ENUM('BAJA', 'NORMAL', 'ALTA', 'CRITICA') DEFAULT 'NORMAL',
        usuario_reporta VARCHAR(100) NOT NULL,
        fecha_reporte TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        fecha_solucion TIMESTAMP NULL,
        tecnico_asignado VARCHAR(100),
        solucion_aplicada TEXT,
        estatus ENUM('ABIERTA', 'EN_PROCESO', 'RESUELTA', 'CANCELADA') DEFAULT 'ABIERTA',
        tiempo_solucion_horas DECIMAL(8,2),
        observaciones TEXT,
        ubicacion_falla VARCHAR(200) NOT NULL,
        impacto ENUM('BAJO', 'MEDIO', 'ALTO', 'CRITICO') DEFAULT 'MEDIO',
        requiere_repuestos BOOLEAN DEFAULT FALSE,
        repuestos_utilizados TEXT,
        costo_reparacion DECIMAL(10,2),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX idx_no_serie (no_serie),
        INDEX idx_estatus (estatus),
        INDEX idx_fecha_reporte (fecha_reporte),
        INDEX idx_tecnico (tecnico_asignado),
        FOREIGN KEY (no_serie) REFERENCES equipo(no_serie) ON UPDATE CASCADE
      )
    `;
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(createTableQuery);
        // Insertar nueva falla
        const insertQuery = `
      INSERT INTO fallas_equipos (
        no_serie, tipo_falla, descripcion_problema, sintomas, prioridad,
        usuario_reporta, tecnico_asignado, ubicacion_falla, impacto,
        requiere_repuestos, observaciones
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;
        const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(insertQuery, [
            no_serie,
            tipo_falla,
            descripcion_problema,
            sintomas || '',
            prioridad,
            usuario_reporta,
            tecnico_asignado || null,
            ubicacion_falla,
            impacto,
            requiere_repuestos ? 1 : 0,
            observaciones
        ]);
        // Actualizar estado del equipo si es necesario
        if (prioridad === 'CRITICA' || impacto === 'CRITICO') {
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(`UPDATE equipo SET EstatusEquipo = 'Fuera de Servicio' WHERE no_serie = ?`, [
                no_serie
            ]);
        } else {
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(`UPDATE equipo SET EstatusEquipo = 'Con Falla' WHERE no_serie = ?`, [
                no_serie
            ]);
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            message: 'Falla registrada exitosamente',
            data: {
                fallaId: result.insertId,
                no_serie,
                tipo_falla,
                estatus: 'ABIERTA'
            }
        });
    } catch (error) {
        console.error('Error creando falla:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            error: 'Error interno del servidor'
        }, {
            status: 500
        });
    }
}
async function PUT(request) {
    try {
        const body = await request.json();
        const { id, estatus, tecnico_asignado, solucion_aplicada, tiempo_solucion_horas, repuestos_utilizados, costo_reparacion, observaciones } = body;
        if (!id) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: 'ID de falla requerido'
            }, {
                status: 400
            });
        }
        let updateQuery = `UPDATE fallas_equipos SET updated_at = CURRENT_TIMESTAMP`;
        const params = [];
        if (estatus) {
            updateQuery += `, estatus = ?`;
            params.push(estatus);
            if (estatus === 'RESUELTA') {
                updateQuery += `, fecha_solucion = CURRENT_TIMESTAMP`;
            }
        }
        if (tecnico_asignado !== undefined) {
            updateQuery += `, tecnico_asignado = ?`;
            params.push(tecnico_asignado);
            if (tecnico_asignado && estatus !== 'RESUELTA') {
                updateQuery += `, estatus = 'EN_PROCESO'`;
            }
        }
        if (solucion_aplicada !== undefined) {
            updateQuery += `, solucion_aplicada = ?`;
            params.push(solucion_aplicada);
        }
        if (tiempo_solucion_horas !== undefined) {
            updateQuery += `, tiempo_solucion_horas = ?`;
            params.push(tiempo_solucion_horas);
        }
        if (repuestos_utilizados !== undefined) {
            updateQuery += `, repuestos_utilizados = ?`;
            params.push(repuestos_utilizados);
        }
        if (costo_reparacion !== undefined) {
            updateQuery += `, costo_reparacion = ?`;
            params.push(costo_reparacion);
        }
        if (observaciones !== undefined) {
            updateQuery += `, observaciones = ?`;
            params.push(observaciones);
        }
        updateQuery += ` WHERE id = ?`;
        params.push(id);
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(updateQuery, params);
        // Si la falla se resolvió, actualizar estado del equipo
        if (estatus === 'RESUELTA') {
            // Buscar el número de serie de la falla
            const fallaQuery = `SELECT no_serie FROM fallas_equipos WHERE id = ?`;
            const fallaResult = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(fallaQuery, [
                id
            ]);
            if (fallaResult.length > 0) {
                const no_serie = fallaResult[0].no_serie;
                // Verificar si hay otras fallas abiertas para este equipo
                const otrasFallasQuery = `
          SELECT COUNT(*) as count 
          FROM fallas_equipos 
          WHERE no_serie = ? AND estatus IN ('ABIERTA', 'EN_PROCESO') AND id != ?
        `;
                const otrasFallas = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(otrasFallasQuery, [
                    no_serie,
                    id
                ]);
                // Si no hay otras fallas, poner el equipo como activo
                if (otrasFallas[0].count === 0) {
                    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$database$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["executeQuery"])(`UPDATE equipo SET EstatusEquipo = 'Activo' WHERE no_serie = ?`, [
                        no_serie
                    ]);
                }
            }
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            message: 'Falla actualizada exitosamente'
        });
    } catch (error) {
        console.error('Error actualizando falla:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            error: 'Error interno del servidor'
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__bc8ba1e7._.js.map